Chapter 31: Semaphores 
One needs both locks and conditions to solve concurrency problems

Semaphore is a synchronization primitive 
    a single primitive for all things related to synchronization, one can
    use semaphores as both locks and condition variables 

*** Semaphores: A Definition ***
A Semaphore is an obkect with an integer value that we can maipulate with
two routines; in the POSIX standard, these routines are sem_wait() and 
sem_post(). 
    The initial value of the semaphore determines its behavior, before 
    calling any other routine to interact with the semaphore, we must
    firs initialize it 

#include <semaphore.h>v  // this looks like we are initializing sem_t
sem_t s;                 // then adding pointer s to init with value 0, 1
sem_init(&s, 0, 1);

In the figure we declare a semaphore (s) and initialize it to the value 1
    by passing 1 in as the third argument. The second argument to 
    sem_init() will be set to 0 in all of the examples we see, this 
    indicates that the semaphore is shared between threads in the same 
    process 

In the new code we see that sem_wait() will either return right away
    (because the value of the semaphore was one or higher when we called 
    sem wait()) or it will cause the caller to suspend execution 
    waiting for suspension post Multiple threads may call into sem_wait
    () and thus all be qued waiting to be woken 

we can see that sem_post() does not wait for some particular condition 
    to hold like sem_wait() does. Rather it simply increments the value 
    of the sephamore and then, if there is a thread waiting to be woken
    wakes up one of them 

Third the value of semaphore, when negative, is equal to the number of 
    waiting threads. Though generally isn't seen by users of the semaphores, this is worth knowing 

*** Binary Semaphores (Locks) ***
For using a semaphore, figure 31.3 shows that they simply surround the
    ciritical section of interested with a sem_wait() / sem_post() pair. 
    in order for this to work this needs to occure to initialize the 
    value of semaphore m. (Initialize to X in the figure) - what is x? -
        x should be 1

Example: 
    In this senario there are two threads
    the first calls sem_wait()l it will first decrement the semaphore to
    0, in thread 0. then it will only wait() if the value is greater 
    than or equal to 0. Because the value is 0, semiwait() will return 
    and allow the calling thread will continue. Thread 0 is now free to 
    enter critical section. if no other thread tries to get the lock 
    while thread 0 is inside the citical sectionm when it calls sem_post
    () it will restore the value of the semaphore to 1 (not wake a 
    waiting therad, because none exist) 

    Thread 0 can hold the lock (when it calls sem_wait() but not 
    sem_post()) and another thread tries to enter the citical section by
    calling sem_wait(), thread 1 will decrement the value of the 
    semaphore to -1 and this wait (putting itself to sleep and 
    relinquishing the processor)

    When therad 0 runs again it will eventually call sem_post() 
    incrementing the value of the semaphore back to 0, then wake the 
    wake the waiting thread (thread 1) which will then be able to aquire 
    the lock itself. When thread 1 finishes it will increment the value 
    of the semaphore, retoring it to 1 again 

    Question: Why does thread 0 not go to sleep?
        Note that Thread 1 goes into the sleeping state when it tries to
        acquire the already-held lock; only when Thread 0 runs again can 
        Thread 1 be awoken and potentially run again.
        Question: What dictates a thread to hold a lock? does one thread 
        have to be wait and the other post?
    
*** sephamore for ordering ***
Semaphores are also useful to order events in a concurrent program.

Example: A thread may with to wait for a list to become non empty so it
    can delete an element from it.

In this pattern of usage we often find one thread waiting for something
    to happen, and another thread making that something happen and then 
    signaling that it has happenedm thus waking the waiting thread. We 
    are thus using the sephamore as an ordering primitive 

what should the initial value of this semaphore be? The answer, of 
    course, is that the value of the semaphore should be set to is 0.
There are two cases:
    First, the parent creates the child but the child has not run yet 
        (it is sitting) in a ready queue but not running) The parent 
        will call sem_wait() before the child has called sem_post(); 
        we'd like the parent to wait for the child to run. The only way 
        this will happen is if the value of the sephamore is not greater 
        than 0; hence 0, is the intial value. The parent runs, decrements
        the sephamore (to -1) then waits (sleeping). When the child 
        finally runs, it will call sem_post() increment the value of the
        sephamore to 0 and wake the parent which will then return from sem_wait() and finish the program. 

The second case occurs when the child runs to completion before the 
    parent gets a chance to call sem_wait(). In this case the child will 
    first call sem_post() thus incrementing the value  of the semaphore 
    from 0 to 1. When the parent runs, it will call sem_wait() and find 
    the value of semaphore to be 1; the parent will thus decrement the 
    value (to 0) and return from sem_wait() without waiting also 
    achieving the desired effect. 

*** The Producer/Consumer (Bounded Buffer) Problem ***
