Chapter 36: I/o
CPU is attached to the main memory of the system of the system via
    some kind of memory bus or interconnect. Some of the devices are 
    to the system via a general I/O bus, which in modern systems are 
    call PCI graphics and some other high preformance I/O devices might 
    be found there 
Lower down are one or more of peripheral bus, such as SCSI, Sata, or USB
    USB devices include disks, mouse, or keyboard these are slow 

We need heirarchical structures simply for physics and cost. The faster a
    bus is the shorter is must be, thus a high performance memory bus doe
    not have much room to plug devices into 

Engineering a bus for high performance is costly so a hierarchical 
    approach where components that demand high performance (liek 
    graphics) cards are closer to the CPU. lower performance are 
    farther away 

*** A Canonical Device ***
A device has two important components. The first is hardware interface 
    and the second is internal structure.
    Hardware Interface: hardware must also have some kind of interface 
        that allows the system software to control its operation. The 
        hardware must have some kind of interface that allows the system 
        software to control its operation. Thus all devices have a 
        specified interface and protocol for typical interaction
    Internal Structure: This part of the device is implementation 
        specific and is responsible for implemenating the abstraction 
        the device presents to the system. Very simple devices will have 
        one or a few hardware chips to implement their functionality; 
        more complex devices will include a simple CPU, some general 
        purpose memory, and other device-specific chips to get their job 
        done.

*** Canonical protocol ***
Device interface is compromised of three registers:
    Status register: can be read to see the current status of the device 
    Command Register: To tell the device to perform a certain task 
    Data Register: pass data to the device or get data from the device 
Polling: OS waits until the device is ready to recieve a command by 
    repeatedly reading the status register (OS is asking whats going 
    on)
Protocols have 4 steps:
Typical interaction that the OS might have with a device is: 
    first, OS waits until the device is ready to recieve command
    second, OS sends data down to the register
    third, OS writes a command to the command register, doing so lets 
        the device know data is present and it can start working on the 
        command
    fourth, OS waits for the device to finish by again polling in a loop
        waiting to see if it is finished (it may then get an error code)


Chapter 37: HardDisk Drives
Main form of persistent data storage 

*** Interface ***
Drive consists of a large number of sectors (512-byte blocks) each of 
    which can be written or read 

The sectors are numbered from 0 to n -1 on a disk with n sectors. We can
    view the disk as an array of sectors, 0 to n-1 is thus the address
    space 

The only guarentee drive manufacturers make is that a single 512-byte 
    write is atomic, it will either complete in its entireety or it 
    wont comeplete at all, thus if a power loss occurs only a portion of
    a larger write may complete (torn write)

THere is an "unwritten contract" of disk drives. It assumes that 
    accessing two blocks near one another is faster than accessing block
    that are farther away. Thus accessing blocks in a contiguous
    (touching) chunks is the fastests access mode and usually much 
    faster than a random access pattern

*** Basic Geometry ***
Platter: a circular surface on which data is stores persistently by
    inducing magnetic changes to it. Drives may have one or more platters
    Each platter has 2 sides, each side called a surface
Spindle: The platters are bound together by the spindle, its connected to
    the motor that spins the platter around while the drive is powered on
    and it spins at a constant fixed rate. (7200 to 15000 RPM). Single 
    rotation takes around 6ms
Track: Data is encoded on each surface in concentric circles of sectors,
    we call it a track. a surface holds thousands of tracks
Disk Head/Disk Arm: The head is the hardhard that read/write onto the 
    surface. The head is moved around using the disk arm 

*** Simple Disk Drive ***
simple disk with a single track (Figure 37.1). This track has just 12 
    sectors, each of which is 512 bytes in size (our typical sector 
    size, recall) and addressed therefore by the numbers 0 through 11. 
    The single platter we have here rotates around the spindle, to which 
    a motor is attached.

*** SIngle track latency: The rotational Delay ***
To process a request hour disk just waits for the desired sector to 
    rotate under the disk head.
Rotational Delay: THe process of waiting for a sector to rotate under 
    the head. The delay can be described by (R/2)

*** Multiple tracks: seek time ***
Seek: To service a read the drive has to first move the disk arm to the
    correct track, this process is called seek
Seek has multiple phases: 
    Acceleration: the disk arm gets moving, then 
    coasting: as the arm is moving at full speed 
    deceleration: arm slows down 
    setting: the head is carefully positioned over the correct track 

After the seek, the disk arm has positioned the head over the right
    track.

The settling time is often quite significant .5 to .2 ms 

After the desired sector is under the disk head the final phase of I/O 
    will take place called transfer
    transfer: data is either read from or written to the surface

*** Other details ***
Track Skew: to make sure that sequential reads can be properly serviced 
    even when crossing track boundarie. 

Without the skew the head would be moved to the next track but the 
    desired next block would have passed thus needing to do a full 
    rotation

multi-zoned disk drives, where the disk is organized into multiple 
    zones, and where a zone is consecutive set of tracks on a surface.

cache, for historical reasons sometimes called a track buffer. This
    cache is just some small amount of memory (usually around 8 or 16 
    MB) which the drive can use to hold data read from or written to the 
    disk. 

When should the disk acknowledge the write has completed when it puts the
    data in its memory or after the write has been written to disk. 
    Write back(immidiate reporting): Complete when data is in memory 
    Write through: Complete when data is written to disk 

I/O time: Doing math for disk performance (pg 7)
T(I/O) = T(seek) + T(rotation) + T(transfer)
Random Workload: Reads to random locations on disk, common in database
Sequential Workload: reads a large number of sectors consecutively from
    disk. 
Random is much faster than sequential. People will spend large amount of 
    money on fast transfer and less on cheap but large storage amount 
    (check this)

*** Disk Scheduling ***
By estimating the seek and possible rotational delay of a request, the disk scheduler can know how long
each request will take, and thus (greedily) pick the one that will take the
least time to service first. Thus, the disk scheduler will try to follow the
principle of SJF (shortest job first) in its operation.

*** Shortest Seek time first ***
SSTF or Shorest seek first (SSF) orders the queue of IO requests by track
    picking requests on the nearest tracks to complete first. 

When is SSF not the best pick? 
    When drive geometry is not available (when would it not be avai? 
        servers?) to the host OS rather it sees a block of arrays
    In that case we use, nearest block first(NBF) which schedules 
        the request with the nearest block address first 

    Second, is the issue of starvation: If many requests happen on one
        specific track the other requests, for other tracks, will not be
        given resources.

*** Elevator (SCAN or C-SCAN) ***
An alogorithum that moves back and forth across the disk servicing 
    requests in order across tracks. 

Sweep: a single pass across the disk 
    If a request comes for a block on a track that has already been 
    serviced on this sweep of the disk it is not handled immediately but 
    rather queued until the next sweep 

Scan has many vaients, some, Fscan, Cscan, 

Scan does not represent the best scheduling tech: it does not really
    adhere to shortest job first, it ignored rotation

CRUX: What algorithum can take into account seek and rotation?

*** SPTF: Shortest positioning time first ***
or shortest access time first (SATF) is the solution to the CRUX
    The answer to which sector should a head move to is, it depends.
    THe answer lies in the why does it depends and the details around it
    For this asnwer the depends is, relative time of seeking as compared 
        to rotation. If rotation is faster, then SSTF is good, if seek 
        time is faster then seeking further is better 

--- Livny's Law ---
Almost any question can be answered with "it depends" 

*** Other scheduling issues ***
Where is disk scheduling done?
In older systems, the operating system did all the scheduling; after 
    looking through the set of pending requests, the OS would pick the 
    best one, and issue it to the disk. When that request completed, the 
    next one would be chosen, and so forth. Disks were simpler then, and 
    so was life.

In modern systems, disks can accommodate multiple outstanding requests, 
    and have sophisticated internal schedulers themselves (which can
    implement SPTF accurately; inside the disk controller, all relevant 
    details are available, including exact head position). Thus, the OS 
    scheduler usually picks what it thinks the best few requests are 
    (say 16) and issues them all to disk; the disk then uses its 
    internal knowledge of head position and detailed track layout 
    information to service said requests in the best possible (SPTF) 
    order.

