Chapter 36: I/o
CPU is attached to the main memory of the system of the system via
    some kind of memory bus or interconnect. Some of the devices are 
    to the system via a general I/O bus, which in modern systems are 
    call PCI graphics and some other high preformance I/O devices might 
    be found there 
Lower down are one or more of peripheral bus, such as SCSI, Sata, or USB
    USB devices include disks, mouse, or keyboard these are slow 

We need heirarchical structures simply for physics and cost. The faster a
    bus is the shorter is must be, thus a high performance memory bus doe
    not have much room to plug devices into 

Engineering a bus for high performance is costly so a hierarchical 
    approach where components that demand high performance (liek 
    graphics) cards are closer to the CPU. lower performance are 
    farther away 

*** A Canonical Device ***
A device has two important components. The first is hardware interface 
    and the second is internal structure.
    Hardware Interface: hardware must also have some kind of interface 
        that allows the system software to control its operation. The 
        hardware must have some kind of interface that allows the system 
        software to control its operation. Thus all devices have a 
        specified interface and protocol for typical interaction
    Internal Structure: This part of the device is implementation 
        specific and is responsible for implemenating the abstraction 
        the device presents to the system. Very simple devices will have 
        one or a few hardware chips to implement their functionality; 
        more complex devices will include a simple CPU, some general 
        purpose memory, and other device-specific chips to get their job 
        done.

*** Canonical protocol ***
Device interface is compromised of three registers:
    Status register: can be read to see the current status of the device
    Command Register: To tell the device to perform a certain task 
    Data Register: pass data to the device or get data from the device 
Polling: OS waits until the device is ready to recieve a command by 
    repeatedly reading the status register (OS is asking whats going 
    on)
Protocols have 4 steps:
Typical interaction that the OS might have with a device is: 
    first, OS waits until the device is ready to recieve command
    second, OS sends data down to the register
    third, OS writes a command to the command register, doing so lets 
        the device know data is present and it can start working on the 
        command
    fourth, OS waits for the device to finish by again polling in a loop
        waiting to see if it is finished (it may then get an error code)

This is a simple and working protocol but it does come with issues:
    the polling is inefficient and inconveniences involved 
    it wastes a great deal of CPU time just waiting for the device to complete
        its activity instead of switching to another process 

*** Lowering the COU overhead with interrupts ***
Instead of polling the OS can issue an interrupt put the calling process to sleep 
    and context switch to another task 
When device is finally finished with the operation it will raise a hardware interrupt
    causing the CPU to jump into the OS at a presetermined interrupt service routine (ISR)

interrupts thus allow for overlap of computation and I/O which is key for improved utilization
    Instead of polling the CPU can run a different process while waiting for the first one to be done 
    thus waking up process 1 after it is done 

Not situtations are best suited for interrupts, if a device polls fast then an interrupt may make 
    the process slower. Thus, if a device is fast, it may be best to poll; if it is slow, interrupts,
    which allow overlap, are best.

If the speed of the device is not known, or sometimes fast and sometimes slow, it may be best to use 
    a hybrid that polls for a little while and then, if the device is not yet finished, uses interrupts. 
    This two-phased approach may achieve the best of both worlds.

livelock, that is, find itself only processing interrupts and never allowing a user-level process 
    to run and actually service the re-quests.

coalescing. In such a setup, a device which needs to raise an interrupt first waits for a bit before delivering 
    the interrupt to the CPU. While waiting, other requests may soon complete, and thus multiple interrupts can be
    coalesced into a single interrupt delivery, thus lowering the overhead of interrupt processing.

 *** More efficient data movement with DMA ***
A DMA engine is essentially a very specific device within a system that can orchestrate transfers 
    between devices and main memory without much CPU intervention.
    The OS would program the DMA engine by telling it where the data lives in memory, how much data to copy and 
    which device to send it to. At that point the OS is done with the transfer and can proceed with other work. When
    DMA is complete the DMA controller raises an interrupt and the OS knows the transfer is complete 

*** Methods of Device interaction ***
Two primary methods of device communication have been developed 
    First, using I/O instructions - these instructions specify a way for the OS to send data 
        to specific device registers and thus allow the construction of the protocols 
        The os controls devices the the OS thus is the only entity allowed to directly 
        communicate with them 
    Second, using Memory mapped I/O. The hardware makes device registers available as 
        if they were memory locations. To access a particular register the OS issues a load
        (to read) or store (to write) the addressl the hardware then routes the load/store 
        to the device instead of main memory 
    
*** Fitting into the OS: The Device Driver ***
The last issue, how do we fit devices, each of which have very specific interfaces, into the 
    OS which we would like to keep as general as possible
    
Problem is solved through abstraction
    At the lowest level a piece of software in the OS must know in detail how a device works. 
    We call this piece of software a device driver and any specifics of device interaction are
    encapsulated within

The encapsulation can have downsides as well 
    If there is a device that has many special capabilities but has to present a generic interface
    to the rest of the kernel those special capabilities will go unused. ALl devices go with a baseline
    capabilities and special add on will be lost to the file system.

An IDE disk presents a simple interface to the system, consisting of four types of registers: 
    control, command blocks, status, and error 
    These registers are available by reading or writing to specific I/O addresses 
    The basic protocol to interact with the device is as follows:
        Wait for drive to be ready 
        Write perameters to command registers 
        Start the I/O
        Data transfer 
        Handle interrupts 
        Error handling 

There are four primary functions in the protocol; 
    first, ide_rw() which queues a reqest or issues it directly to the disk. the routine waits for the request to complete 
        and the calling process to sleep 
    second, ide_start_request() used to send a request to the disk, in and out x86 instructions are called to read and write 
        device registers 
    the start request routine uses the third function, ide_wait_ready() to ensure the drive is ready before issuing a request 
    finally the fourth, ide_intr() is invoked when an interrupt takes place it reads data from the device, wakes the prcess waiting 
        for the I/O to complete and launches the next I/O via ide_start_request()



